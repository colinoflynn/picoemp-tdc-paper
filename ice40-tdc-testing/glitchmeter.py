
#### ICE40 CLASS

# Example of using PyFTDI to program CRAM on ICE40 FPGA. For example
# if you are using IceBreaker, you'd need to change jumpers to route
# SPI to the FPGA directly instead of the SPI flash.

import chipwhisperer as cw
from chipwhisperer.hardware.naeusb.programmer_targetfpga import LatticeICE40
from chipwhisperer.hardware.naeusb.spi import SPI

import os
import subprocess
import time

#### DAC CLASS

import serial
import time
class DAC(object):
    def __init__(self, comport, def1200=True):
        self.ser = serial.Serial(comport)

        if def1200:
            self.ser.write(b"1200\n")

    def set_mv(self, mv):
        self.ser.write(b'%d\n'%mv)
        self.ser.read_all()

#### YOSYS BUILD CLASS

import os
import sys

class YosysBuild(object):

    def __init__(self, dir=None):
        if dir:
            self.dir = dir
        else:
            self.dir = "."
    
    def output_settings(self, num_delay_elements=32, trigger_mode="always", trigger_condition="~wdata[9]"):

        files = "// WARNING - THIS FILE AUTOGENERATED\n"
        files += "// Called with: output_settings(\n" + \
                 "//              num_delay_elements=%d,\n"%num_delay_elements + \
                 "//              trigger_mode=%s,\n"%trigger_mode + \
                 "//              trigger_condition='%s')\n\n"%trigger_condition

        files += "`define NUM_DELAY_ELEMENTS %d\n"%num_delay_elements
        files += "`define TDC_DLYS_PER_TAP 1\n\n"


        files += "//Define 'WE_NEVER', 'WE_ALWAYS', or 'WE_TRIGGERED'\n"
        if trigger_mode == "never" or trigger_mode == None:
            files += "`define WE_NEVER\n"
        elif trigger_mode == "always":
            files += "`define WE_ALWAYS\n"
        elif trigger_mode == "triggered" or trigger_mode == "trigger":
            files += "`define WE_TRIGGERED\n"
        else:
            raise ValueError("trigger_mode needs to be 'never', 'always', 'trigger'")
        files += "\n"

        files += "`define TRIGGER_CONDITION (%s)\n"%trigger_condition

        f = open(os.path.join(self.dir, "settings.v"), "w")
        f.write(files)
        f.close()
    
    def build(self):
        subprocess.run("apio build", cwd=self.dir, shell=True, check=True)

class GlitchMeter():

    def __init__(self, daccom=None, coremv=1200, dir="rtl"):
        # Connect to scope
        scope = cw.scope()
        scope.default_setup()
        scope.clock.clkgen_freq = 20E6
        scope.io.tio1 = False
        scope.io.tio2 = None
        scope.io.tio4 = False

        self.scope = scope

        self.YB = YosysBuild(dir)
        
        if daccom:
            self.dac = DAC(daccom)
        else:
            self.dac = None

        if coremv:
            self.set_coremv(coremv)

        self.ice = LatticeICE40(scope)
    
    def set_coremv(self, mv):
        self.dac.set_mv(mv)
    
    def build_and_load(self, num_delay_elements=32, trigger_mode="always", trigger_condition="~wdata[9]"):

        self.YB.output_settings(num_delay_elements, trigger_mode, trigger_condition)
        self.YB.build()

        self.ice.erase_and_init()
        self.ice.program(os.path.join("rtl", "hardware.bin"))

    def getpattern(self, printpattern=False):
        BRAM_WIDTH = 32

        scope = self.scope

        spi = spi = SPI(scope._getNAEUSB(), cs_line=(scope.io, "pdid"))
        spi.enable(500E3)
        data = spi.transfer([0x00]*256)
        data = [bytearray(data[i:(i + int(BRAM_WIDTH/8))]) for i in range(0, len(data), int(BRAM_WIDTH/8))]

        if printpattern:
            for d in data:
                h = d.hex()
                b = format(int(h, 16), "0%db"%BRAM_WIDTH)
                print(b)

        spi.disable()

        return data